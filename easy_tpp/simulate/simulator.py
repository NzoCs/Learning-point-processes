from easy_tpp.config_factory import SimulatorConfig
from easy_tpp.utils import logger

import json
import os
from typing import List, Dict, Optional
from tqdm import tqdm
import random

class Simulator:
    """
    A wrapper class to generate simulations using a pre-trained temporal point process model.

    This class takes a configuration object, a pre-trained model, and historical data
    (optional but required for simulation continuation) to generate event sequences.
    The generated sequences are then formatted and saved in a structure similar to
    the data generated by `easy_tpp.data_gen`, allowing for unified data handling.
    The data can be split into training, development, and testing sets.
    """
    
    def __init__(self, simulator_config: SimulatorConfig) -> None:
        """
        Initializes the Simulator.

        Args:
            simulator_config (SimulatorConfig): Configuration object containing simulation parameters.
        """
        
        #configuration for simulation
        self.save_dir = simulator_config.save_dir

        #Load the model
        self.model = simulator_config.pretrained_model

        #data_config
        self.history_data_module = simulator_config.history_data_module
        self.split = simulator_config.split
        self.history_data_module.setup(stage=self.split)
        self.num_event_types = self.history_data_module.num_event_types
        self.max_size = simulator_config.max_size

        #seed
        self.seed = simulator_config.seed

    def run(self) -> None:
        """
        Executes the simulation process.

        Generates event sequences based on the provided model and history data (if any),
        formats them, splits them according to the configuration, and saves them to disk
        along with metadata. Requires `history_data` to be provided in the config.
        """
        
        model = self.model
        history_data = self.history_data_module
        
        if history_data is None:
            logger.error("history_data is required for simulation but was not provided.")
            raise ValueError("history_data must be provided for simulation based on historical context.")
        
        logger.info(f"Starting generation of simulations")
        simulations = []
        
        try:
            data_loader = history_data.get_dataloader(split=self.split)
        except Exception as e:
            logger.error(f"Failed to get dataloader from history_data: {e}")
            raise RuntimeError("Could not obtain dataloader from the provided history_data object.") from e

        events_count =  0
        for batch in tqdm(data_loader, desc="Generating simulations", unit="batch"):
            batch_values = batch.values()
            time_seq, time_delta_seq, event_seq, simul_mask = model.simulate(batch=batch_values)

            batch_size = time_seq.size(0)

            for i in range(batch_size):
                mask_i = simul_mask[i]
                if mask_i.any():
                    simulations.append({
                        'time_seq': time_seq[i][mask_i].clone().detach(),
                        'time_delta_seq': time_delta_seq[i][mask_i].clone().detach(),
                        'event_seq': event_seq[i][mask_i].clone().detach(),
                    })

            events_count += simul_mask.sum()
            if events_count >= self.max_size:
                break
        logger.info(f"Successfully generated simulations.")
        
        logger.info("Formatting generated simulations...")
        formatted_data = self.format_multivariate_simulations(
            simulations, self.num_event_types
        )
        logger.info("Formatting complete.")
        
        self.save_data(formatted_data)
    
    def format_multivariate_simulations(self, simulations: List[Dict], dim_process: Optional[int]) -> List[Dict]:
        """
        Formats the raw simulation results into a list of dictionaries, one per sequence.

        Each dictionary follows a structure similar to Hugging Face datasets,
        containing event times, time deltas, event types, sequence length, etc.

        Args:
            simulations (List[Dict]): A list where each dict contains tensors
                                      ('time_seq', 'time_delta_seq', 'event_seq')
                                      for a single simulated sequence.
            dim_process (Optional[int]): The number of event types (dimensionality) in the process.

        Returns:
            List[Dict]: A list of dictionaries, each representing a formatted sequence.
        """
        formatted_data = []
        
        for seq_idx, sim in enumerate(tqdm(simulations, desc="Formatting sequences")):
            times = sim['time_seq']
            events = sim['event_seq']
            time_deltas = sim['time_delta_seq']
            
            times = times - times[0]  

            times_list = times.cpu().tolist()
            events_list = events.cpu().long().tolist()
            time_deltas_list = time_deltas.cpu().tolist()
            
            if not times_list:
                logger.warning(f"Skipping empty simulation sequence at index {seq_idx}.")
                continue

            seq_dict = {
                'dim_process': dim_process if dim_process is not None else -1,
                'seq_len': len(times_list),
                'seq_idx': seq_idx,
                'time_since_start': times_list,
                'time_since_last_event': time_deltas_list,
                'type_event': events_list
            }
            formatted_data.append(seq_dict)
        
        return formatted_data
    
    def save_data(self, formatted_data: List[Dict]) -> None:
        """
        Saves the formatted simulation data into a single file.
        Also saves metadata.

        Args:
            formatted_data (List[Dict]): The list of formatted simulation sequences.
        """
        num_total_seqs = len(formatted_data)
        if num_total_seqs == 0:
            logger.warning("No formatted data to save.")
            self.save_metadata(formatted_data)
            return

        if self.seed is not None:
            random.seed(self.seed)
            random.shuffle(formatted_data)
            logger.info("Shuffled formatted data using the provided seed.")
        else:
            random.shuffle(formatted_data)
            logger.info("Shuffled formatted data randomly (no seed provided).")

        output_filename = 'simulations.json'
        filepath = os.path.join(self.save_dir, output_filename)
        self.save_json(formatted_data, filepath)

        self.save_metadata(formatted_data)
        logger.info(f"All simulated data has been saved in {self.save_dir}")
    
    def save_json(self, data: List[Dict], filepath: str) -> None:
        """
        Saves data to a JSON file with indentation.

        Args:
            data (List[Dict]): The data to save (typically a list of dictionaries).
            filepath (str): The full path where the JSON file will be saved.
        """
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2)
        except IOError as e:
            logger.error(f"Failed to save JSON file to {filepath}: {e}")
        except TypeError as e:
             logger.error(f"Data structure not serializable to JSON for {filepath}: {e}")

    def save_metadata(self, formatted_data: List[Dict]) -> None:
        """
        Saves metadata about the simulation run, including configuration details
        and total event counts.

        Args:
            formatted_data (List[Dict]): The list of all formatted sequences (used for stats).
        """
        total_events = sum(item.get('seq_len', 0) for item in formatted_data)
        avg_seq_len = total_events / len(formatted_data) if formatted_data else 0

        metadata = {
            'simulation_summary': {
                'total_sequences_generated': len(formatted_data),
                'total_events_generated': total_events,
                'average_sequence_length': round(avg_seq_len, 2),
                'dimension': self.num_event_types if self.num_event_types is not None else 'Unknown',
                'simulation_time_interval': [self.model.simulation_start_time, self.model.simulation_end_time],
                'generating_model': self.model.__class__.__name__ if self.model else 'Unknown',
                'seed_used': self.seed
            }
        }

        meta_filepath = os.path.join(self.save_dir, 'metadata.json')
        self.save_json(metadata, meta_filepath)
        logger.info(f"Metadata saved to {meta_filepath}")
